what do you think about this? this is my first draft of my new programming language (which I created on accident); it's a shell/script for managing a 3D environment (create/destroy objects; append vertices to objects; modifie them; ...); as mentioned, this is my first draft, and not even close to being ready; I'll add features, and very likely change syntax (as I'm pretty experimental with that, as you'll see); 
test.ces:
ceate(Hans)                                                             // create an object "Hans"
Hans.vert_count = 3                                                     // set "Hans" vertex count
Hans.v1.x = 1.1                                                         // set x, y and z coordinates of "Hans" manually
Hans.v1.y = 2.2
Hans.v2.z = 3.3
Hans.v2.x = 1.1
Hans.v2.y = 1.2
Hans.v2.z = 2.1
Hans.v3.x = 2.2
Hans.v3.x = 2.3


Move(Hans)->vec(1, 0, 0)                                                // move hans using a Vector (a vector of value (1, 0, 0))

create(Peter)                                                           // create object called "Peter"
Peter.vert_count = 4                                                    // set "Peters vertex count
Peter.v1 = (->Hans.v1.x, ->Hans.v1.y, ->Hans.v1.z)                      // set "Peter"s first vertex; "->Hans.v1.x" means "x coordinate of Hans' first vertex, and change if this changes";
Peter.v2 = (55.2, -1.2, 0)                                              // set "Peter"s second vertex; demonstrate that you don't have to go through the nightare that is the above (Hans)
Peter.v3 = vMove(->Hans.v1.x, 1.1, ->Peter.v2.z)                        // set "Peter"s third vertex; this time we even reference a value of it's own vertices
Peter.v4 = zyx(0, -1.2, 55)                                             // same as Peters 2 vertex; abc(n, m, o) indicates: objects a coordinate is 
                                                                        // n, b coordinate is m, and c coordinnate is o (a, b, c) are of (x, y, z) (yes, you could do xxx(1, 2, 3);
                                                                        // last value overwrites previous ones); defaults to xyz, if nothing else is provided
// this is a comment!
Move(Peter)->(1, 1, 1)                                                  // sets object center to (1, 1, 1); center is automatically calculated uppon update to object (which can be disabled; demonstrated
                                                                        // further down)
Hans.e1 = ->v1_->v2                                                         
Hans.e2 = ->v2_->v3                                                     // creates edges between two vertices (notice that we're not using Hans.v1 here, since only own vertices can be used)
Hans.e2 = ->v3_->v4

mod(create_edges):                                                      // create a modification (similar to def in Python) with the name "create_edges"; mods can only be used on objs;    
    takes: num_edges(int);                                              // "takes" keyword to list inputs, seperated by ";". "(int)" is used as a typehint; for type checks: <type>
    for vert in vertices-ind(1):                                        // for loops; we've got them; notice how we call vertices instead of object.vertices; mod has to be used on an object 
        /                                                               // when calling "vertices" here, we call the vertices of the object calling the function; ind(1) is the last index of this list
        e[cui] = ->v[cui]_->v[cui+1]                                    // we now define each edge; cui is the current index/loop count; this is automatically calculated (when used) when a loop is 
        /                                                               // used. the x[y] syntax is used to append to a variable name; for instance, e[1] is the same as e1, though [x] allows for 
        /                                                               // processing of the index;

proc = Peter.create_edges                                               // functions are treated like variables here, until they're run; here, we assign proc (a function) to a function taking Peter
/                                                                       // as "main-obj" (have to find a better word for this), such that by calling vertices inside of create-edges, we call 
/                                                                       // Peter.vertices; this is usefull, because we can now reuse functions with already existing inputs, which makes it more efficient
/                                                                       // (have to phrase the above better)
proc.num_edges = Peter.vert_count                                       // sets an input. this is, too, treated like a variable; notice: we could also use the arrow notation here to dynamically
/                                                                       // change "num_edges" based around the current state
proc.run(Peter)                                                         // acctually calls the function, and stores the modified object in "Peter"


ChatGPT said:
ChatGPT

Your draft for the new programming language is an intriguing concept with a focus on managing and modifying 3D environments. Below are some thoughts and constructive feedback:
Positives

    Readable Syntax for 3D Operations:
        The ability to create and manipulate 3D objects (Hans, Peter) is expressed in a clear and readable way.
        Use of arrow notation (->Hans.v1.x) to reference and dynamically link properties is a clever feature, especially for scenarios involving dependency updates.

    Extensibility:
        The mod construct for defining reusable modifications is a great idea, aligning with modular programming principles.
        Treating functions (mods) as objects that can be assigned to variables and manipulated before execution is innovative and flexible.

    Strong Typing Features:
        The use of type hints ((int)) in mods provides clarity and the potential for type-checking or even static analysis.

    Object Relationships and Flexibility:
        The ability to reference other objects dynamically (->Hans.v1.x) and perform transformations (e.g., vMove) adds flexibility.

    Commenting and Documentation:
        Support for comments (both inline and block) is well-implemented, aiding readability and collaboration.

Suggestions for Improvement

    Syntax Refinement:
        The mixed use of ->, parentheses, and custom delimiters (->v1_->_v2) might confuse new users. A consistent approach (or shorthand) could improve usability.
        Example: Instead of ->v1_->_v2, perhaps use connect(v1, v2) or similar to standardize edge definitions.

    Variable Management:
        The e[cui] syntax is useful but introduces complexity. Consider allowing both e1 and e[1] while abstracting away the indexing logic for clarity.

    Object State Updates:
        The default behavior of automatically recalculating properties (e.g., center) is helpful but might benefit from clear controls. For example, a toggle like object.auto_update(True/False).

    Error Handling and Edge Cases:
        Add safeguards for referencing objects that don’t exist or are not fully initialized. For example:

    Hans.v5.x = 1.0  // What happens if v5 is out of bounds?

Documentation of Built-ins:

    Built-in functions like vMove, xyz, and zyx should be well-documented. An auto-generated manual or language reference would make the language easier to learn.

Loop Constructs:

    The for vert in vertices-ind(1) syntax could be simplified for easier comprehension:

    for vert in vertices[:-1]:

    This would align with familiar Python-like syntax while still being explicit.

Consistency in Method Calling:

    Combining property setting (proc.num_edges) with function execution (proc.run(Peter)) might be confusing. Perhaps use a single mechanism like:

        proc.set(num_edges=Peter.vert_count).run()

Ideas for Future Features

    Namespaces and Scoping:
        Introduce namespaces for large projects:

        namespace Scene1 {
            create(Hans)
        }

    Interactive Environment:
        A REPL for live testing and tweaking object properties or modifications in real-time.

    Error Reporting and Debugging Tools:
        Built-in debugging, such as debug(object) to list properties, vertices, and dependencies.

    Integration with 3D Tools:
        Export to popular formats (e.g., OBJ, STL) or interoperate with tools like Blender.

    Performance Considerations:
        Optimize dynamic linking (e.g., ->Hans.v1.x) for real-time updates without sacrificing performance.

Overall Impression

Your language shows great potential, especially for tasks involving procedural 3D modeling and manipulation. While it is in its early stages, the concepts are innovative and cater to niche yet important use cases. Refining the syntax and ensuring consistency will make it more approachable while retaining its powerful features.

Keep iterating, and this could evolve into a highly specialized and useful tool for 3D environment management!


You said:
ok. I take the critic, but I'll have to explain myself; it appears my docmentation was not sufficient; first: the arrow syntax; arrow syntax provides dynamic access to a value. for instance:
create(Hans)
Hans.vert_count = 1
Hans.v1 = (1, 2, 3)
test = -> Hans.v1.x
some_log_function_I'll_have_to_implement(test)            // will output "1"
vMove(Hans)->Vec(1, 0, 0)
some_log_function_I'll_have_to_implement(test)           // will output "2"
it is also used for any sort of vector deformation (see ...->Vec...); I'll admit, that might propose a problem, but I'm sure they'll get the hang of it eventually; it is NOT a linking function, nor will it work like that (for now). it's basically a pointer and a dereference to the location of the given variable, whereas for instance Hans.v1.x would just copy the value; then: I'm aware, that "->v1_->v2" is in any way and for INSANE. though I cannot use some sort of function(->v1, ->v2) (notice I still use arrows, as I'm dynamically calling them), as that would be confused with the other parentheses using functions. I chose the "_" for all opperations bringing two objects into relation; so to create a face between two edges, I'll implement:
object.f1 = ->e1_->e2; and some other stuff to; also: I wrote into the docs, that e[1] is the same as e1; cui can also be called outside of []; if I were to implement cui i python I'd do:
cui = 1;
for i in some_list:
    do_something...
    cui++
it's just a counter of the already performed loops; this variable will not exist however, if the loop doesn't referece it anywhere within; additionally: the [] syntax is somewhat equivalent to pythons eval(...) function, in that it takes some expresion, and returns a value. though it can be used on variables too (as seen by e[cui]); why do I use e[cui] here? I can only statically define the edge using ex where x is some number; by putting [cui], this generates cui that can be appeded to e. in python:
cui = 1
Peter_es = [] #just to show how this would work; of course is's more complex than a list
for i in range(len(vertices)-1):
    eval(f"Peter_es[{cui}] = something...")
    cui++
I know the above python code would fail, because Peter_es doesn't have an index one, but again, it's not a list, it's a kind of dynamically allocated typedef struct which expands in size uppon appending to it; then: default behaviour of center I also said was able to be changed. and I had something similar in mind (not some function, but a variable); then: error handling: of course I'm going to have that. I'm not just going to let my code crash!; but I have to build up some error structure. thanks for the reminder!; also: loop constructs: I don't want to be too python like. and it's supposed to be experimental and critizised as heck, so I can keep the best new stuff in, while through feedback remove the unecacary/bad stuff the people don't like; the rest I'll take. thank you
2/2
ChatGPT said:
ChatGPT

Thank you for the clarification! It’s evident you’ve put significant thought into your language design, and the additional context helps illuminate your decisions and intent. Let me revisit and refine my feedback considering your explanations:
Arrow Syntax Clarification

Your explanation of the arrow syntax as a dynamic pointer/dereference mechanism makes its purpose clearer:

    Strengths: It’s powerful for dynamic referencing, especially when combined with real-time updates like vMove. Users familiar with pointers will appreciate its utility.
    Consideration: While the dual use of arrows (dereferencing and vector deformation) could cause some confusion initially, your choice aligns with the experimental nature of your language. Clear documentation will mitigate misunderstandings.

Relational Underscore (_) Syntax

I now understand why ->v1_->v2 was chosen for relationships. It’s:

    A distinct separator to define relations.
    Consistent with potential future constructs like object.f1 = ->e1_->e2.

While unconventional, the underscore emphasizes the relational aspect. To ease understanding:

    Suggestion: Consider aliasing with a higher-level abstraction if this pattern becomes widespread. For instance:

    Hans.edge(v1, v2) // High-level alias for ->v1_->v2

    This could appeal to users preferring simplicity without removing the underlying power.

Loop Counters (cui)

Your implementation of cui as an implicit loop counter makes sense, especially with your dynamic variable model:

    The design avoids introducing extra variables unless explicitly referenced, which keeps loops lightweight.
    Tip: Clearly document cui's lifecycle (e.g., it only exists when explicitly used) to avoid surprises for new users.

Dynamic Allocation and Typedef-Like Structures

Your approach to dynamic allocation using e[cui] as an expandable construct is innovative. By dynamically defining edges (or other entities) based on loop variables, you’re creating a flexible system. The Python analogy helps make this clear:

    Strengths: Dynamism is great for complex environments where relationships evolve frequently.
    Potential Enhancement: Consider user feedback on whether explicit dynamic structures like this are intuitive or require a steep learning curve.

Experimental Constructs

Your openness to critique and feedback is one of the strongest aspects of your design process. The experimental features, even if unconventional, are where innovation thrives. As a strategy:

    Retain features like ->v1_->v2 for power users but provide simplified alternatives for newcomers to ease adoption.
    Track user pain points during experimentation, as these often reveal the constructs that need refining or removing.

Error Handling

You’re right that robust error handling is critical, especially for a language managing dynamic and relational data. A potential approach:

    Implement a structured error system (e.g., with categories like syntax errors, reference errors, and runtime errors).
    Example:

    try {
        Move(Hans)->vec(1, 0, 0)
    } catch ReferenceError as e {
        log(e.message)
    }

Your Vision and the Future

Your willingness to push boundaries and invite criticism is admirable. While the syntax may initially feel unconventional, the reasoning behind your choices aligns with the experimental goals of the language. Clear documentation, error handling, and thoughtful abstractions will make it easier for others to appreciate and adopt your ideas.

If you keep refining with this level of care and feedback integration, your language could become a highly innovative tool in 3D scripting and beyond. Keep at it, and I’d love to hear about future iterations!



























ChatGPT said:
ChatGPT

You've clearly put significant effort into developing your 3D object manipulation library, and it's great to see a foundational structure emerging! Here's an analysis of your code and suggestions to enhance its functionality, safety, and readability:
Observations:

    Dynamic Object Management:
        You're dynamically allocating and managing vertices, objects, and scenes. This approach is commendable for flexibility but needs rigorous memory management to avoid leaks.

    Debugging Utilities:
        The debug_obj and debug_scn functions are well-structured and provide comprehensive insights into objects and scenes. These are invaluable for testing and debugging.

    Input Handling:
        Extensive use of scanf introduces potential risks like buffer overflows and undefined behavior if inputs are malformed. Error handling for inputs could be improved.

    Object Manipulation:
        Functions like append_vert_to_obj, move_object_vec, and calculate_obj_center are clear and effectively perform their tasks.

    Repetition and Recursion:
        Some recursive calls in create_obj and move_object seem intended for error recovery. However, they could lead to stack overflow in edge cases.

    Error Handling:
        While you've considered some errors, like duplicate object names or excessive vertex counts, these could benefit from more centralized handling.

    Magic Numbers and Strings:
        Hardcoded limits, such as 30 for names and 25 for vertices, should be replaced with defined constants for better maintainability.

Suggestions:
1. Error and Input Validation:

    Use safer functions like fgets for string input:

    char buffer[30];
    if (fgets(buffer, sizeof(buffer), stdin)) {
        buffer[strcspn(buffer, "\n")] = '\0'; // Remove newline
    }

    Validate numeric inputs and handle conversion errors gracefully.

2. Memory Management:

    Ensure you free dynamically allocated memory in destructors for objects, scenes, and vertices:

    void free_object(obj *object) {
        free(object->vertices);
        free(object->name);
        free(object->center);
    }
    void free_scene(scene *Scene) {
        for (int i = 0; i < Scene->obj_count; ++i) {
            free_object(&Scene->objects[i]);
        }
        free(Scene->objects);
        free(Scene->name);
    }

3. Avoid Recursion for Input Recovery:

    Replace recursive calls with loops:

    while (true) {
        printf("Enter object name:\n");
        scanf("%29s", name);
        if (is_valid_name(name)) break;
        printf("Invalid name. Try again.\n");
    }

4. Use Enums and Constants:

    Define constants for sizes and error codes:

    #define MAX_NAME_LENGTH 30
    #define MAX_VERTICES 25

    Replace hardcoded strings like "vector" or "position" with enums.

5. Simplify Object Initialization:

    Consider factory functions to reduce repetitive initialization code:

    obj *create_object(const char *name, int vertex_count) {
        obj *new_obj = malloc(sizeof(obj));
        new_obj->name = strdup(name);
        new_obj->vertices = calloc(vertex_count, sizeof(vert));
        new_obj->vertex_count = vertex_count;
        new_obj->center = calloc(1, sizeof(vert));
        return new_obj;
    }

6. Centralize Logging:

    Create a logging utility for consistent debug output:

    void log_debug(const char *message, ...) {
        va_list args;
        va_start(args, message);
        vprintf(message, args);
        va_end(args);
    }

7. Optimize Scene Functions:

    Functions like append_obj_to_scene_by_object could preallocate memory to reduce frequent reallocations. For example:

    #define INITIAL_SCENE_CAPACITY 10
    Scene->objects = realloc(Scene->objects, new_capacity * sizeof(obj));

8. Enhance the Interpreter Layer:

    Integrate a structured command parser to handle actions (debug, move, create) robustly. Tokenize input commands and map them to functions.

Potential Additions:

    Matrix Transformations:
        Add matrix-based transformations (rotation, scaling).

    Error Codes:
        Standardize error handling with return codes or errno.

    File I/O:
        Support saving/loading scenes to/from files for persistence.

    Thread Safety:
        Consider thread safety if objects/scenes are manipulated concurrently.

Next Steps:

    Address input safety (fgets, buffer validation).
    Implement memory cleanup functions to avoid leaks.
    Modularize the code into header/source files for better organization (object.c, scene.c, debug.c).

You're on the right track for building a robust 3D library! As you transition from the shell to an interpreter, consider implementing a REPL (Read-Eval-Print Loop) for more user-friendly interaction.